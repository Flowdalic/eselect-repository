# Copyright (c) 2017 Michał Górny
# 2-clause BSD license

DESCRIPTION="Manage repository list in repos.conf"
MAINTAINER="Michał Górny <mgorny@gentoo.org>"
VERSION=0

### directories
# TODO: use substitution on this

CACHEDIR=/tmp
SYSCONFDIR=/etc
SHAREDSTATEDIR=/var
HELPER=./eselect-repo-helper

### configuration
# TODO: make this configurable

REPOS_CONF=${SYSCONFDIR}/portage/repos.conf
# if repos.conf is a directory
REPOS_CONF_SUBFILE=${REPOS_CONF}/eselect-repo.conf
REPOS_BASE=${SHAREDSTATEDIR}/db/repos

REMOTE_LIST_URI=https://qa-reports.gentoo.org/output/repos/repositories.xml
REMOTE_LIST_CACHE=${CACHEDIR}/repositories.xml
# every 2 hours -- mostly to avoid wget output on every command
REMOTE_LIST_REFRESH=$(( 2 * 3600 ))

### helper functions

update_cache() {
	local refts

	if [[ -f ${REMOTE_LIST_CACHE} ]]; then
		refts=$(( $(date '+%s') - REMOTE_LIST_REFRESH ))
		[[ $(find "${REMOTE_LIST_CACHE}" -newermt "@${refts}") ]] && return
	fi

	# do not force server timestamps as they will cause immediate rechecks
	# (If-Modified-Since will work with the current mtime anyway, unless
	# user's clock has drifted seriously)
	wget -N --no-use-server-timestamps -P "${CACHEDIR}" "${REMOTE_LIST_URI}" ||
		die -q "unable to fetch repositories.xml"
}

run_helper() {
	"${HELPER}" \
		--repos-conf "${REPOS_CONF}" \
		--repositories-xml "${REMOTE_LIST_CACHE}" \
		"${@}" ||
		die -q "helper failed to run"
}

# Convert numerical repository indices in ${@}. Store resulting
# repository list as repos=() array.
convert_indices() {
	local have_numerical= r
	for r; do
		if is_number "${r}"; then
			have_numerical=1
		fi
	done

	if [[ ! ${have_numerical} ]]; then
		repos=( "${@}" )
		return
	fi

	[[ -f ${REMOTE_LIST_CACHE} ]] ||
		die -q "unable to use numerical indices before calling 'list'"

	# shift indexes to ease referencing
	local all_repos=( '' )
	local name state
	while read name state; do
		all_repos+=( "${name}" )
	done < <(run_helper list)

	repos=()
	for r; do
		if is_number "${r}"; then
			repos+=( "${all_repos[r]}" )
		else
			repos+=( "${r}" )
		fi
	done
}

### add action

## {{{
describe_add() {
	echo "Add a new repository"
}

describe_add_parameters() {
	echo "(<name>|<index>)..."
}

describe_add_options() {
	echo "<name>...  : Names of repositories to add"
	echo "<index>... : Numeric index of the repository (from 'list' command)"
}

do_add() {
	[[ ${#} -gt 0 ]] || die -q "no repositories specified"

	convert_indices "${@}"
	update_cache

	local r state arg1 arg2 new_lines= added=()
	while read r state arg1 arg2; do
		case ${state} in
			enabled)
				echo "error: ${r}: repository already enabled, in ${arg1}"
				continue
				;;
			not-exist)
				echo "error: ${r}: repository not in repositories.xml"
				continue
				;;
			unsupported)
				echo "error: ${r}: repository source VCS not supported"
				continue
				;;

		esac

		added+=( "${r}" )
		# note: escape all the backslashes for sed, and add command
		# continuations
		new_lines+="\\${new_lines:+
\\}
[${r//\\/\\\\}]\\
location = ${REPOS_BASE//\\/\\\\}/${r//\\/\\\\}\\
sync-type = ${arg1//\\/\\\\}\\
sync-uri = ${arg2//\\/\\\\}"
	done < <(run_helper remote-metadata "${repos[@]}")

	if [[ ${added[@]} ]]; then
		local f
		# if repos.conf is a directory, create a dedicated subfile
		if [[ -d ${REPOS_CONF} ]]; then
			f=${REPOS_CONF_SUBFILE}
		else
			f=${REPOS_CONF}
		fi

		# note: the file must be non-empty for sed to work
		if [[ ! -s ${f} ]]; then
			echo "# created by eselect-repo" > "${f}" || die
		fi

		echo "Updating ${f} ..."
		sed -i -e "\$ a\\
${new_lines}" "${f}" || die

		echo "${#added[@]} repositories added"
	fi
}
## }}}

### delete action

## {{{
describe_delete() {
	echo "Remove installed repository"
}

describe_delete_parameters() {
	echo "[-f] (<name>|<index>)..."
}

describe_delete_options() {
	echo "-f         : Force potentially dangerous removals"
	echo "<name>...  : Names of repositories to delete"
	echo "<index>... : Numeric index of the repository (from 'list' command)"
}

do_delete() {
	local force
	if [[ ${1} == -f ]]; then
		force=1
		shift
	fi
	[[ ${#} -gt 0 ]] || die -q "no repositories specified"

	convert_indices "${@}"
	update_cache

	local r state path removed=()
	while read r state path; do
		case ${state} in
			not-exist)
				echo "error: ${r}: repository not in repos.conf"
				continue
				;;
			local)
				if [[ ! ${force} ]]; then
					echo "error: ${r}: repository not in remote list, pass -f to force removal"
					continue
				fi
				;;
			no-sync-uri)
				if [[ ! ${force} ]]; then
					echo "error: ${r}: repository has no sync-uri, pass -f to force removal"
					continue
				fi
				;;
		esac

		# if path is empty, we still want to remove the config entry
		if [[ ${path} ]]; then
			echo "Removing ${path} ..."
			rm -r -f "${path}"
		fi

		removed+=( "${r}" )
	done < <(run_helper metadata "${repos[@]}")

	if [[ ${removed[@]} ]]; then
		local expr='\('
		for r in "${removed[@]}"; do
			expr+="${r}\|"
		done
		expr="${expr%|})"

		local files=()
		if [[ -d ${REPOS_CONF} ]]; then
			# filter only to files containing the repos
			while IFS= read -r -d '' f; do
				files+=( "${f}" )
			done < <(grep -Z -l "^\s*\[${expr}\]\s*\$" "${REPOS_CONF}"/*)
		else
			files=( "${REPOS_CONF}" )
		fi

		echo "Updating repos.conf ..."
		sed -n -i~ -e "/^\s*\[${expr}\]\s*\$/{b loop}; p; b;
				:loop {n;/^\s*[^\[]/b loop};" "${files[@]}" || die

		echo "${#removed[@]} repositories removed"
	fi
}
## }}}

### list action

## {{{
describe_list() {
	echo "List all repositories"
}

do_list() {
	update_cache

	write_list_start "Available repositories:"
	local name state i=1
	while read name state; do
		case ${state} in
			enabled)
				name=$(highlight_marker "${name}");;
			need-update)
				if ! is_output_mode brief; then
					name+=" $(highlight_warning '#')"
				fi
				;;
		esac
		write_numbered_list_entry "$(( i++ ))" "${name}"
	done < <(run_helper list)
}
## }}}

# vim: ts=4 sw=4 noet fdm=marker
